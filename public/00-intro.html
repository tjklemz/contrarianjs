<h2>Introduction</h2>

<p>This is a book in-progress containing unpopular opinions concerning front-end engineering and development.</p>

<p>Today's front-end teams jump too quickly on the hype train, choosing to use a complicated tech stack without evaluating the particular application to their own problem space. Simply: They over-engineer.</p>

<p>React, Polymer, and the rest have some great concepts. But do they solve <em>your</em> specific problems? Is the problem you're trying to solve primarily a data binding issue? Are you sure a custom solution wouldn't be better?</p>

<p>Frameworks are anti "bottom up" design choices. Regardless of whether a framework fits your problem space, you should still evaluate how much custom domain language is in your application. I've worked on and seen many a web app that boiled down to basic forms. Should you even be writing a Single Page Application if the browser already has concepts of forms? Why are we as an industry constantly trying to reinvent the wheel?</p>

<p>Besides this, there is the claim that React and friends are faster. But... faster than <em>what</em>? And is speed your primary goal? If it is, then what about that initial load time for React? That doesn't bother you? So, you've already made some product assumptions? Seems presumptuous.</p>

<p>A few years ago, Facebook made the claim that HTML5 couldn't cut it for them. They claimed that HTML5 wasn't up to snuff and they'd need their own solution. But the DOM is a highly optimized piece of software. Everyday, developers improve upon these so-called "evergreen" browsers, with updates being released quite frequently, within the realm of one or two weeks.</p>

<p>The browser exposes the highly optimized C++ (or Rust) methods to JavaScript. The renderer and event loop are implemented in the low-level language as well. Google Chrome's engine is famous (or notorious) for predicting JavaScript branching and applying Just-in-time (JIT) compilation to the web page's code. In some cases, using a large framework or library negates the very work being done in the browser. It's a shame.</p>

<p>So many features of plain old JavaScript (affectionately called "vanilla JS") are underutilized. For example: Live NodeLists. A live list that maps directly to the DOM without me needing to re-query? Sign me up!</p>

<p>Part of what has happened is this: Not long ago, web development with plain old HTML/CSS/JS <em>sucked</em>. Remember slicing Photoshop documents and having to do weird hacks to get "fonts" on the web? And remember those terrible, laggy animations?</p>

<p>But those days are gone.</p>

<p>Today, CSS3 provides hardware accelerated drop shadows, vector fonts, and buttery smooth animations. JavaScript now has classList, map, filter, and forEach.</p>

<p>Often, a build system is even unnecessary, as evergreen browsers and servers are now implementing HTTP/2.</p>

<p>So, why are so many apps written with a complicated build system, an overengineered DSL on top of an already and increasingly complex ES6, and a selection of large frameworks and libraries?</p>

<p>I don't know. I really don't. But I'd like to explore the wonderful world of bottom-up design using vanilla JS. It's simple, and simplicity is the core goal of software engineering. But this will require some thinking, some stepping back and looking at what is really being done. There are no plug-n-play solutions here. If you are one who codes more than thinks, you might not enjoy this book. But if you enjoy engineering for simplicity, then this is for you.</p>
